# OIer 注意事项

> 考前救命集锦

0001. 倍增算贡献时要先算贡献, 再将点往上跳
0002. 爆了空间也爆零
0003. 逐字比较样例
0004. 学了高级算法分析能力下降, 一定要多想! 多分析! 不要看题解.
0005. 看题目要仔细
0006. 要学会写对拍
0007. 注意策略和时间
0008. 思考五分钟, 代码两小时, 学会写算法流程图, 想清楚再写
0009. 写的时候模块化
0010. 学会静态查错
0011. 看书和考试的时候多想, 成绩不重要, 重要是锻炼
0012. 题一定要补完 (虽然之前欠了很多)
0013. 读题的时候一定要结合样例
0014. 考试的时候尽量对拍,  (提高代码能力, 减少码代码时间)
0015. 尽量不写快读, 写的话仔细查错
0016. Linux 与 Windows 编译环境差异大, 注意以下情况: 
   1. void 不要写成其他有返回值的函数类型 (int, bool)
   2. 有返回值的函数一定要记得如果不需要返回记得加 return 0,  (不会默认return 0)
0017. 如果准备全力想一道题, 请先打完其他题的暴力
0018. 要搞清楚比赛策略
0019. 加强码力
0020. 用滚动数组时记得清零
0021. 搞清楚有向边和无向边
0022. 板子要复习和巩固, 不要会用但写不对
0023. 在遇到稠密图时, 求最短路要想到floyd
0024. 要善于发现问题中隐藏的单调性, 这可能大大降低复杂度
0025. 如果没有, 要想到去维护, 对于有很多修改的题, 如果没有强制在线, 可以考虑离线, 并通过某种顺序执行来降低复杂度 (eg: 莫队)
0026. 要将描述或求解较为复杂的问题拆成子问题解决
0027. 并查集常维护有传递性的题目 (eg: 等于关系)
0028. 可以染色缩点, 有时朴素想法反而可能更优
0029. 考试的时候千万不要炸心态, 考试时要只想题目
0030. 如果题目要对 2^32 取模或对 2^64 取模要自然想到溢出
0031. 数组的下标可能是另一个数组的一个元素的值, 不要搞错了
0032. 括号匹配一定要搞清楚, 对于较长或较复杂的计算式或判断式要多打空格
0033. 学过的东西一定要记清楚, 实在不行就复习, 一定要搞清楚, 避免会做不会用 (eg: STL)
0034. 排序型贪心一般用邻项微扰证明, 树上贪心一般用决策包容性证明
0035. 把 lower_bound 搞清楚
0036. scanf 和 printf 数据类型要对齐
0037. 注意变量名里如果有数字, 注意不要打反: eg: sum1--sum2
0038. 注意循环里给某个变量初始化时, 不要放错循环
0039. 区间之间如果不相交, 只包含, 可以考虑转化成树上问题
0040. set 等 stl 容器在用 iterator 时注意容器为空或到边界的情况
0041. 同一行函数从右往左调用, (栈)
0042. 数组下标如 i 和 j 千万不要搞反了
0043. 变量名一定要注意不要和关键字冲突了
0044. 线段树在 L <= mid <= R 时, 两个 modify 一个是 (L, mid), 一个是 (mid + 1, R)
0045. 线段树等数据结构空间要开够
0046. type 0 和 1 不要打反了
0047. max 和 min 不要搞错了 (不要复制粘贴, 踏踏实实手打)
0048. 有的样例会被分成两页, 要记得注意
0049. 输出不要肉眼对, 一定要用文件比较, 眼睛对会出错! 
0050. 涉及到前缀和的贪心, 或者说是和顺序有关的 01 背包 (国王游戏) 通常从答案的计算式入手来得到排序方案
0051. 开 long long
0052. 图上问题查不出错考虑检查建图是否出错
0053. 知道 DP 顺序时不要记忆化
0054. 涉及到可以选择交换操作的题目, 考虑某些操作对全局的顺序造成的影响
0055. 当遇到需要确认较少数量的元素的顺序才能转移时, 如果只需知道当前元素与前面元素的关系, 而前面元素内部的关系无所谓时, 就只需维护一个集合
0056. DP 时要尽可能维护多的信息, 但有时也可以舍去不必要信息来降低复杂度
0057. 学会打表
0058. 不在线询问的题都该想一想离线
0059. 离线询问后, 除了可以分治, 还可以分块
0060. 矩阵型计数题目可以考虑按行分治
0061. 按行分治的题目有时也可以按列分治, 两者有时可以交错进行, 优化复杂度
0062. 字符串哈希记得取模
0063. BFS 队列里面是可以放很多点的
0064. 曼哈顿距离可以转成切比雪夫距离
0065. 一些分组 DP 转移想不到怎么优化的时候, 可以确认一下答案的上界, 进而确认 DP 的限制
0066. double 可以输出 -0
0067. 一些涉及到划分和分组的问题如果需要贪心, 影响的东西太多, 可以考虑倒着来, 因为倒着来可以保证某一条限制已经合法
0068. 求凸包等之类计算几何的题目可以想到极角排序, 可以借此确定一些顺序
0069. 计数问题想到容斥
0070. 当在图上可以做出一些改变图结构的决策时或者当点之间的可达关系是由另一个上限很小的权值之间的可达关系决定时, 可以用分层图
0071. 给定序列确定顺序时, 可以看成图上问题, 点与点之间的前后关系可以看成有向边, 拓扑排序
0072. 博弈的题目尽量从终态往前考虑. 并且尽可能将终态简化, 在考虑策略时大力分类讨论, 想细致一点具体一点没坏处
0073. 小心 memset 的时候可能会越界, 数组大小一定不要对应错了
0074. 单元最短路构成了一棵最短路树.
0075. 一些从点出发不好考虑的问题可以从边出发, dp或者松弛之类的操作的时候, 通过观察或转化式子后可以通过贪心策略优化顺序来减少转移次数, 也可以用数据结构
0076. 数组开太大了 memset 会 T
0077. 有时数组下标是负数不会段错误, 但是会 WA
0078. 遇到环的问题一般都要断开
0079. 比较浮点数不要用 <, 最好定一个 eps, 如果说浮点数的误差不超过 eps 的话, 那比较就不会出错
0080. 一定要静态差错
0081. 向量 a 卷向向量 b 的叉乘如果为正代表逆时针! ! 如果为负, 代表顺时针! 不要搞反了
0082. 有的时候 DP 做不来就加一维, 多出那一维也许是可以优化的, 即使状态看起来过不了也是有可能能 A 的.
0083. 一些想不到怎么转移的东西, 可以在转移的时候同时转移另一个用来辅助转移的东西, 如果那个东西转移不了, 就加到状态里面
0084. 一些不能离线的题目, 分析题目的限制, 有可能反过来之后限制会交换, 也就可以倒着做
0085. 即使没有发现负数, 也有可能是 long long 的问题, 请仔细分析每一个变量的精度问题, 这不会花很多时间, 但会救你的命
0086. 一些类似整除分块要一块一块的查询的时候, 比如查前缀和, 请仔细注意第一个块和最后一个块是否越界了并对其进行处理
0087. 实在不会的东西还是问一问
0088. 有些涉及到删边的操作可以从边出发去考虑
0089. 有些题目与操作顺序无关
0090. 想到做法只要还有时间, 就不要立即写, 想一想有没有更简单的做法, 简化做法或优化做法会减少你写代码的时间, 降低挂分的概率, 锻炼你的思维
0091. 没有修改就不要上主席树
0092. 休息很重要, 好好睡觉, 休息好思维会更敏捷, 这是真的
0093. 一些维护起来比较复杂的关系可以考虑维护其逆关系
0094. 一些题目从问题入手, 分析问题的限制条件, 将其抽象出来, 去观察本质, 发现本质瓶颈在哪里, 然后在进行解决, 这个思想很重要, 一定要运用起来
0095. 一些题目中的限制如果是必须为某个数 a, 也可以看成要同时满足 >= a 和 <= a
0096. 定eps可以解决部分精度问题.
0097. 一些题目的答案可能有单调性, 但这种单调性除了正常的单调之外, 也可能是单峰
0098. 贪心的题目大力分类讨论, 不要害怕
0099. vector 内存不会释放 shrink_to_fit 可以释放全部内存
0100. 不要认为自己输出不会写错
0101. 记得检查 printf 的输出格式
